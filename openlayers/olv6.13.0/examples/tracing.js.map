{"version":3,"file":"tracing.js","mappings":"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","sources":["webpack:///./tracing.js"],"sourcesContent":["import Draw from '../src/ol/interaction/Draw.js';\nimport Feature from '../src/ol/Feature.js';\nimport Fill from '../src/ol/style/Fill.js';\nimport GeoJSON from '../src/ol/format/GeoJSON.js';\nimport LineString from '../src/ol/geom/LineString.js';\nimport Map from '../src/ol/Map.js';\nimport Snap from '../src/ol/interaction/Snap.js';\nimport Stroke from '../src/ol/style/Stroke.js';\nimport Style from '../src/ol/style/Style.js';\nimport View from '../src/ol/View.js';\nimport {OSM, Vector as VectorSource} from '../src/ol/source.js';\nimport {Tile as TileLayer, Vector as VectorLayer} from '../src/ol/layer.js';\n\n// math utilities\n\n// coordinates; will return the length of the [a, b] segment\nfunction length(a, b) {\n  return Math.sqrt(\n    (b[0] - a[0]) * (b[0] - a[0]) + (b[1] - a[1]) * (b[1] - a[1])\n  );\n}\n\n// coordinates; will return true if c is on the [a, b] segment\nfunction isOnSegment(c, a, b) {\n  const lengthAc = length(a, c);\n  const lengthAb = length(a, b);\n  const dot =\n    ((c[0] - a[0]) * (b[0] - a[0]) + (c[1] - a[1]) * (b[1] - a[1])) / lengthAb;\n  return Math.abs(lengthAc - dot) < 1e-6 && lengthAc < lengthAb;\n}\n\n// modulo for negative values, eg: mod(-1, 4) returns 3\nfunction mod(a, b) {\n  return ((a % b) + b) % b;\n}\n\n// returns a coordinates array which contains the segments of the feature's\n// outer ring between the start and end points\n// Note: this assumes the base feature is a single polygon\nfunction getPartialRingCoords(feature, startPoint, endPoint) {\n  let polygon = feature.getGeometry();\n  if (polygon.getType() === 'MultiPolygon') {\n    polygon = polygon.getPolygon(0);\n  }\n  const ringCoords = polygon.getLinearRing().getCoordinates();\n\n  let i,\n    pointA,\n    pointB,\n    startSegmentIndex = -1;\n  for (i = 0; i < ringCoords.length; i++) {\n    pointA = ringCoords[i];\n    pointB = ringCoords[mod(i + 1, ringCoords.length)];\n\n    // check if this is the start segment dot product\n    if (isOnSegment(startPoint, pointA, pointB)) {\n      startSegmentIndex = i;\n      break;\n    }\n  }\n\n  const cwCoordinates = [];\n  let cwLength = 0;\n  const ccwCoordinates = [];\n  let ccwLength = 0;\n\n  // build clockwise coordinates\n  for (i = 0; i < ringCoords.length; i++) {\n    pointA =\n      i === 0\n        ? startPoint\n        : ringCoords[mod(i + startSegmentIndex, ringCoords.length)];\n    pointB = ringCoords[mod(i + startSegmentIndex + 1, ringCoords.length)];\n    cwCoordinates.push(pointA);\n\n    if (isOnSegment(endPoint, pointA, pointB)) {\n      cwCoordinates.push(endPoint);\n      cwLength += length(pointA, endPoint);\n      break;\n    } else {\n      cwLength += length(pointA, pointB);\n    }\n  }\n\n  // build counter-clockwise coordinates\n  for (i = 0; i < ringCoords.length; i++) {\n    pointA = ringCoords[mod(startSegmentIndex - i, ringCoords.length)];\n    pointB =\n      i === 0\n        ? startPoint\n        : ringCoords[mod(startSegmentIndex - i + 1, ringCoords.length)];\n    ccwCoordinates.push(pointB);\n\n    if (isOnSegment(endPoint, pointA, pointB)) {\n      ccwCoordinates.push(endPoint);\n      ccwLength += length(endPoint, pointB);\n      break;\n    } else {\n      ccwLength += length(pointA, pointB);\n    }\n  }\n\n  // keep the shortest path\n  return ccwLength < cwLength ? ccwCoordinates : cwCoordinates;\n}\n\n// layers definition\n\nconst raster = new TileLayer({\n  source: new OSM(),\n});\n\n// features in this layer will be snapped to\nconst baseVector = new VectorLayer({\n  source: new VectorSource({\n    format: new GeoJSON(),\n    url: \"https://ahocevar.com/geoserver/wfs?service=wfs&request=getfeature&typename=topp:states&cql_filter=STATE_NAME='Idaho'&outputformat=application/json\",\n  }),\n});\n\n// this is were the drawn features go\nconst drawVector = new VectorLayer({\n  source: new VectorSource(),\n  style: new Style({\n    stroke: new Stroke({\n      color: 'rgba(100, 255, 0, 1)',\n      width: 2,\n    }),\n    fill: new Fill({\n      color: 'rgba(100, 255, 0, 0.3)',\n    }),\n  }),\n});\n\n// this line only appears when we're tracing a feature outer ring\nconst previewLine = new Feature({\n  geometry: new LineString([]),\n});\nconst previewVector = new VectorLayer({\n  source: new VectorSource({\n    features: [previewLine],\n  }),\n  style: new Style({\n    stroke: new Stroke({\n      color: 'rgba(255, 0, 0, 1)',\n      width: 2,\n    }),\n  }),\n});\n\nconst map = new Map({\n  layers: [raster, baseVector, drawVector, previewVector],\n  target: 'map',\n  view: new View({\n    center: [-12986427, 5678422],\n    zoom: 5,\n  }),\n});\n\nlet drawInteraction, tracingFeature, startPoint, endPoint;\nlet drawing = false;\n\nconst getFeatureOptions = {\n  hitTolerance: 10,\n  layerFilter: (layer) => {\n    return layer === baseVector;\n  },\n};\n\n// the click event is used to start/end tracing around a feature\nmap.on('click', (event) => {\n  if (!drawing) {\n    return;\n  }\n\n  let hit = false;\n  map.forEachFeatureAtPixel(\n    event.pixel,\n    (feature) => {\n      if (tracingFeature && feature !== tracingFeature) {\n        return;\n      }\n\n      hit = true;\n      const coord = map.getCoordinateFromPixel(event.pixel);\n\n      // second click on the tracing feature: append the ring coordinates\n      if (feature === tracingFeature) {\n        endPoint = tracingFeature.getGeometry().getClosestPoint(coord);\n        const appendCoords = getPartialRingCoords(\n          tracingFeature,\n          startPoint,\n          endPoint\n        );\n        drawInteraction.removeLastPoint();\n        drawInteraction.appendCoordinates(appendCoords);\n        tracingFeature = null;\n      }\n\n      // start tracing on the feature ring\n      tracingFeature = feature;\n      startPoint = tracingFeature.getGeometry().getClosestPoint(coord);\n    },\n    getFeatureOptions\n  );\n\n  if (!hit) {\n    // clear current tracing feature & preview\n    previewLine.getGeometry().setCoordinates([]);\n    tracingFeature = null;\n  }\n});\n\n// the pointermove event is used to show a preview of the result of the tracing\nmap.on('pointermove', (event) => {\n  if (tracingFeature && drawing) {\n    let coord = null;\n    map.forEachFeatureAtPixel(\n      event.pixel,\n      (feature) => {\n        if (tracingFeature === feature) {\n          coord = map.getCoordinateFromPixel(event.pixel);\n        }\n      },\n      getFeatureOptions\n    );\n\n    let previewCoords = [];\n    if (coord) {\n      endPoint = tracingFeature.getGeometry().getClosestPoint(coord);\n      previewCoords = getPartialRingCoords(\n        tracingFeature,\n        startPoint,\n        endPoint\n      );\n    }\n    previewLine.getGeometry().setCoordinates(previewCoords);\n  }\n});\n\nconst snapInteraction = new Snap({\n  source: baseVector.getSource(),\n});\n\nconst typeSelect = document.getElementById('type');\n\nfunction addInteraction() {\n  const value = typeSelect.value;\n  if (value !== 'None') {\n    drawInteraction = new Draw({\n      source: drawVector.getSource(),\n      type: typeSelect.value,\n    });\n    drawInteraction.on('drawstart', () => {\n      drawing = true;\n    });\n    drawInteraction.on('drawend', () => {\n      drawing = false;\n      previewLine.getGeometry().setCoordinates([]);\n      tracingFeature = null;\n    });\n    map.addInteraction(drawInteraction);\n    map.addInteraction(snapInteraction);\n  }\n}\n\ntypeSelect.onchange = function () {\n  map.removeInteraction(drawInteraction);\n  map.removeInteraction(snapInteraction);\n  addInteraction();\n};\naddInteraction();\n"],"names":["length","a","b","Math","sqrt","isOnSegment","c","lengthAc","lengthAb","dot","abs","mod","getPartialRingCoords","feature","startPoint","endPoint","polygon","getGeometry","getType","getPolygon","i","pointA","pointB","ringCoords","getLinearRing","getCoordinates","startSegmentIndex","cwCoordinates","cwLength","ccwCoordinates","ccwLength","push","drawInteraction","tracingFeature","raster","TileLayer","source","OSM","baseVector","VectorLayer","VectorSource","format","GeoJSON","url","drawVector","style","Style","stroke","Stroke","color","width","fill","Fill","previewLine","Feature","geometry","LineString","previewVector","features","map","Map","layers","target","view","View","center","zoom","drawing","getFeatureOptions","hitTolerance","layerFilter","layer","on","event","hit","forEachFeatureAtPixel","pixel","coord","getCoordinateFromPixel","getClosestPoint","appendCoords","removeLastPoint","appendCoordinates","setCoordinates","previewCoords","snapInteraction","Snap","getSource","typeSelect","document","getElementById","addInteraction","value","Draw","type","onchange","removeInteraction"],"sourceRoot":""}