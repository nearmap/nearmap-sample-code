{"version":3,"file":"geolocation-orientation.js","mappings":"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","sources":["webpack:///./geolocation-orientation.js"],"sourcesContent":["import Geolocation from '../src/ol/Geolocation.js';\nimport LineString from '../src/ol/geom/LineString.js';\nimport Map from '../src/ol/Map.js';\nimport OSM from '../src/ol/source/OSM.js';\nimport Overlay from '../src/ol/Overlay.js';\nimport TileLayer from '../src/ol/layer/Tile.js';\nimport View from '../src/ol/View.js';\nimport {fromLonLat} from '../src/ol/proj.js';\n\n// creating the view\nconst view = new View({\n  center: fromLonLat([5.8713, 45.6452]),\n  zoom: 19,\n});\n\nconst tileLayer = new TileLayer({\n  source: new OSM(),\n});\n\n// creating the map\nconst map = new Map({\n  layers: [tileLayer],\n  target: 'map',\n  view: view,\n});\n\n// Geolocation marker\nconst markerEl = document.getElementById('geolocation_marker');\nconst marker = new Overlay({\n  positioning: 'center-center',\n  element: markerEl,\n  stopEvent: false,\n});\nmap.addOverlay(marker);\n\n// LineString to store the different geolocation positions. This LineString\n// is time aware.\n// The Z dimension is actually used to store the rotation (heading).\nconst positions = new LineString([], 'XYZM');\n\n// Geolocation Control\nconst geolocation = new Geolocation({\n  projection: view.getProjection(),\n  trackingOptions: {\n    maximumAge: 10000,\n    enableHighAccuracy: true,\n    timeout: 600000,\n  },\n});\n\nlet deltaMean = 500; // the geolocation sampling period mean in ms\n\n// Listen to position changes\ngeolocation.on('change', function () {\n  const position = geolocation.getPosition();\n  const accuracy = geolocation.getAccuracy();\n  const heading = geolocation.getHeading() || 0;\n  const speed = geolocation.getSpeed() || 0;\n  const m = Date.now();\n\n  addPosition(position, heading, m, speed);\n\n  const coords = positions.getCoordinates();\n  const len = coords.length;\n  if (len >= 2) {\n    deltaMean = (coords[len - 1][3] - coords[0][3]) / (len - 1);\n  }\n\n  const html = [\n    'Position: ' + position[0].toFixed(2) + ', ' + position[1].toFixed(2),\n    'Accuracy: ' + accuracy,\n    'Heading: ' + Math.round(radToDeg(heading)) + '&deg;',\n    'Speed: ' + (speed * 3.6).toFixed(1) + ' km/h',\n    'Delta: ' + Math.round(deltaMean) + 'ms',\n  ].join('<br />');\n  document.getElementById('info').innerHTML = html;\n});\n\ngeolocation.on('error', function () {\n  alert('geolocation error');\n  // FIXME we should remove the coordinates in positions\n});\n\n// convert radians to degrees\nfunction radToDeg(rad) {\n  return (rad * 360) / (Math.PI * 2);\n}\n// convert degrees to radians\nfunction degToRad(deg) {\n  return (deg * Math.PI * 2) / 360;\n}\n// modulo for negative values\nfunction mod(n) {\n  return ((n % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);\n}\n\nfunction addPosition(position, heading, m, speed) {\n  const x = position[0];\n  const y = position[1];\n  const fCoords = positions.getCoordinates();\n  const previous = fCoords[fCoords.length - 1];\n  const prevHeading = previous && previous[2];\n  if (prevHeading) {\n    let headingDiff = heading - mod(prevHeading);\n\n    // force the rotation change to be less than 180Â°\n    if (Math.abs(headingDiff) > Math.PI) {\n      const sign = headingDiff >= 0 ? 1 : -1;\n      headingDiff = -sign * (2 * Math.PI - Math.abs(headingDiff));\n    }\n    heading = prevHeading + headingDiff;\n  }\n  positions.appendCoordinate([x, y, heading, m]);\n\n  // only keep the 20 last coordinates\n  positions.setCoordinates(positions.getCoordinates().slice(-20));\n\n  // FIXME use speed instead\n  if (heading && speed) {\n    markerEl.src = 'data/geolocation_marker_heading.png';\n  } else {\n    markerEl.src = 'data/geolocation_marker.png';\n  }\n}\n\n// recenters the view by putting the given coordinates at 3/4 from the top or\n// the screen\nfunction getCenterWithHeading(position, rotation, resolution) {\n  const size = map.getSize();\n  const height = size[1];\n\n  return [\n    position[0] - (Math.sin(rotation) * height * resolution * 1) / 4,\n    position[1] + (Math.cos(rotation) * height * resolution * 1) / 4,\n  ];\n}\n\nlet previousM = 0;\nfunction updateView() {\n  // use sampling period to get a smooth transition\n  let m = Date.now() - deltaMean * 1.5;\n  m = Math.max(m, previousM);\n  previousM = m;\n  // interpolate position along positions LineString\n  const c = positions.getCoordinateAtM(m, true);\n  if (c) {\n    view.setCenter(getCenterWithHeading(c, -c[2], view.getResolution()));\n    view.setRotation(-c[2]);\n    marker.setPosition(c);\n    map.render();\n  }\n}\n\n// geolocate device\nconst geolocateBtn = document.getElementById('geolocate');\ngeolocateBtn.addEventListener(\n  'click',\n  function () {\n    geolocation.setTracking(true); // Start position tracking\n\n    tileLayer.on('postrender', updateView);\n    map.render();\n\n    disableButtons();\n  },\n  false\n);\n\n// simulate device move\nlet simulationData;\nconst client = new XMLHttpRequest();\nclient.open('GET', 'data/geolocation-orientation.json');\n\n/**\n * Handle data loading.\n */\nclient.onload = function () {\n  simulationData = JSON.parse(client.responseText).data;\n};\nclient.send();\n\nconst simulateBtn = document.getElementById('simulate');\nsimulateBtn.addEventListener(\n  'click',\n  function () {\n    const coordinates = simulationData;\n\n    const first = coordinates.shift();\n    simulatePositionChange(first);\n\n    let prevDate = first.timestamp;\n    function geolocate() {\n      const position = coordinates.shift();\n      if (!position) {\n        return;\n      }\n      const newDate = position.timestamp;\n      simulatePositionChange(position);\n      window.setTimeout(function () {\n        prevDate = newDate;\n        geolocate();\n      }, (newDate - prevDate) / 0.5);\n    }\n    geolocate();\n\n    tileLayer.on('postrender', updateView);\n    map.render();\n\n    disableButtons();\n  },\n  false\n);\n\nfunction simulatePositionChange(position) {\n  const coords = position.coords;\n  geolocation.set('accuracy', coords.accuracy);\n  geolocation.set('heading', degToRad(coords.heading));\n  const projectedPosition = fromLonLat([coords.longitude, coords.latitude]);\n  geolocation.set('position', projectedPosition);\n  geolocation.set('speed', coords.speed);\n  geolocation.changed();\n}\n\nfunction disableButtons() {\n  geolocateBtn.disabled = 'disabled';\n  simulateBtn.disabled = 'disabled';\n}\n"],"names":["view","View","center","fromLonLat","zoom","tileLayer","TileLayer","source","OSM","map","Map","layers","target","markerEl","document","getElementById","marker","Overlay","positioning","element","stopEvent","addOverlay","positions","LineString","geolocation","Geolocation","projection","getProjection","trackingOptions","maximumAge","enableHighAccuracy","timeout","deltaMean","on","position","getPosition","accuracy","getAccuracy","heading","getHeading","speed","getSpeed","m","x","y","fCoords","getCoordinates","previous","length","prevHeading","headingDiff","Math","PI","abs","appendCoordinate","setCoordinates","slice","src","addPosition","Date","now","coords","len","rad","html","toFixed","round","join","innerHTML","alert","previousM","updateView","max","rotation","resolution","height","c","getCoordinateAtM","setCenter","getResolution","getSize","sin","cos","setRotation","setPosition","render","simulationData","geolocateBtn","addEventListener","setTracking","disableButtons","client","XMLHttpRequest","open","onload","JSON","parse","responseText","data","send","simulateBtn","simulatePositionChange","set","projectedPosition","longitude","latitude","changed","disabled","coordinates","first","shift","prevDate","timestamp","geolocate","newDate","window","setTimeout"],"sourceRoot":""}