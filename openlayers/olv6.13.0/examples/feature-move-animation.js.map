{"version":3,"file":"feature-move-animation.js","mappings":"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","sources":["webpack:///../src/ol/geom/flat/flip.js","webpack:///../src/ol/format/Polyline.js","webpack:///./feature-move-animation.js"],"sourcesContent":["/**\n * @module ol/geom/flat/flip\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {Array<number>} [opt_dest] Destination.\n * @param {number} [opt_destOffset] Destination offset.\n * @return {Array<number>} Flat coordinates.\n */\nexport function flipXY(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  opt_dest,\n  opt_destOffset\n) {\n  let dest, destOffset;\n  if (opt_dest !== undefined) {\n    dest = opt_dest;\n    destOffset = opt_destOffset !== undefined ? opt_destOffset : 0;\n  } else {\n    dest = [];\n    destOffset = 0;\n  }\n  let j = offset;\n  while (j < end) {\n    const x = flatCoordinates[j++];\n    dest[destOffset++] = flatCoordinates[j++];\n    dest[destOffset++] = x;\n    for (let k = 2; k < stride; ++k) {\n      dest[destOffset++] = flatCoordinates[j++];\n    }\n  }\n  dest.length = destOffset;\n  return dest;\n}\n","/**\n * @module ol/format/Polyline\n */\nimport Feature from '../Feature.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport LineString from '../geom/LineString.js';\nimport TextFeature from './TextFeature.js';\nimport {assert} from '../asserts.js';\nimport {flipXY} from '../geom/flat/flip.js';\nimport {get as getProjection} from '../proj.js';\nimport {getStrideForLayout} from '../geom/SimpleGeometry.js';\nimport {inflateCoordinates} from '../geom/flat/inflate.js';\nimport {transformGeometryWithOptions} from './Feature.js';\n\n/**\n * @typedef {Object} Options\n * @property {number} [factor=1e5] The factor by which the coordinates values will be scaled.\n * @property {GeometryLayout} [geometryLayout='XY'] Layout of the\n * feature geometries created by the format reader.\n */\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the Encoded\n * Polyline Algorithm Format.\n *\n * When reading features, the coordinates are assumed to be in two dimensions\n * and in [latitude, longitude] order.\n *\n * As Polyline sources contain a single feature,\n * {@link module:ol/format/Polyline~Polyline#readFeatures} will return the\n * feature in an array.\n *\n * @api\n */\nclass Polyline extends TextFeature {\n  /**\n   * @param {Options} [opt_options] Optional configuration object.\n   */\n  constructor(opt_options) {\n    super();\n\n    const options = opt_options ? opt_options : {};\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.dataProjection = getProjection('EPSG:4326');\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.factor_ = options.factor ? options.factor : 1e5;\n\n    /**\n     * @private\n     * @type {import(\"../geom/GeometryLayout\").default}\n     */\n    this.geometryLayout_ = options.geometryLayout\n      ? options.geometryLayout\n      : GeometryLayout.XY;\n  }\n\n  /**\n   * @protected\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromText(text, opt_options) {\n    const geometry = this.readGeometryFromText(text, opt_options);\n    return new Feature(geometry);\n  }\n\n  /**\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n   * @protected\n   * @return {Array<Feature>} Features.\n   */\n  readFeaturesFromText(text, opt_options) {\n    const feature = this.readFeatureFromText(text, opt_options);\n    return [feature];\n  }\n\n  /**\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromText(text, opt_options) {\n    const stride = getStrideForLayout(this.geometryLayout_);\n    const flatCoordinates = decodeDeltas(text, stride, this.factor_);\n    flipXY(flatCoordinates, 0, flatCoordinates.length, stride, flatCoordinates);\n    const coordinates = inflateCoordinates(\n      flatCoordinates,\n      0,\n      flatCoordinates.length,\n      stride\n    );\n    const lineString = new LineString(coordinates, this.geometryLayout_);\n\n    return transformGeometryWithOptions(\n      lineString,\n      false,\n      this.adaptOptions(opt_options)\n    );\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default<LineString>} feature Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n   * @protected\n   * @return {string} Text.\n   */\n  writeFeatureText(feature, opt_options) {\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      return this.writeGeometryText(geometry, opt_options);\n    } else {\n      assert(false, 40); // Expected `feature` to have a geometry\n      return '';\n    }\n  }\n\n  /**\n   * @param {Array<import(\"../Feature.js\").default<LineString>>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n   * @protected\n   * @return {string} Text.\n   */\n  writeFeaturesText(features, opt_options) {\n    return this.writeFeatureText(features[0], opt_options);\n  }\n\n  /**\n   * @param {LineString} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n   * @protected\n   * @return {string} Text.\n   */\n  writeGeometryText(geometry, opt_options) {\n    geometry =\n      /** @type {LineString} */\n      (\n        transformGeometryWithOptions(\n          geometry,\n          true,\n          this.adaptOptions(opt_options)\n        )\n      );\n    const flatCoordinates = geometry.getFlatCoordinates();\n    const stride = geometry.getStride();\n    flipXY(flatCoordinates, 0, flatCoordinates.length, stride, flatCoordinates);\n    return encodeDeltas(flatCoordinates, stride, this.factor_);\n  }\n}\n\n/**\n * Encode a list of n-dimensional points and return an encoded string\n *\n * Attention: This function will modify the passed array!\n *\n * @param {Array<number>} numbers A list of n-dimensional points.\n * @param {number} stride The number of dimension of the points in the list.\n * @param {number} [opt_factor] The factor by which the numbers will be\n *     multiplied. The remaining decimal places will get rounded away.\n *     Default is `1e5`.\n * @return {string} The encoded string.\n * @api\n */\nexport function encodeDeltas(numbers, stride, opt_factor) {\n  const factor = opt_factor ? opt_factor : 1e5;\n  let d;\n\n  const lastNumbers = new Array(stride);\n  for (d = 0; d < stride; ++d) {\n    lastNumbers[d] = 0;\n  }\n\n  for (let i = 0, ii = numbers.length; i < ii; ) {\n    for (d = 0; d < stride; ++d, ++i) {\n      const num = numbers[i];\n      const delta = num - lastNumbers[d];\n      lastNumbers[d] = num;\n\n      numbers[i] = delta;\n    }\n  }\n\n  return encodeFloats(numbers, factor);\n}\n\n/**\n * Decode a list of n-dimensional points from an encoded string\n *\n * @param {string} encoded An encoded string.\n * @param {number} stride The number of dimension of the points in the\n *     encoded string.\n * @param {number} [opt_factor] The factor by which the resulting numbers will\n *     be divided. Default is `1e5`.\n * @return {Array<number>} A list of n-dimensional points.\n * @api\n */\nexport function decodeDeltas(encoded, stride, opt_factor) {\n  const factor = opt_factor ? opt_factor : 1e5;\n  let d;\n\n  /** @type {Array<number>} */\n  const lastNumbers = new Array(stride);\n  for (d = 0; d < stride; ++d) {\n    lastNumbers[d] = 0;\n  }\n\n  const numbers = decodeFloats(encoded, factor);\n\n  for (let i = 0, ii = numbers.length; i < ii; ) {\n    for (d = 0; d < stride; ++d, ++i) {\n      lastNumbers[d] += numbers[i];\n\n      numbers[i] = lastNumbers[d];\n    }\n  }\n\n  return numbers;\n}\n\n/**\n * Encode a list of floating point numbers and return an encoded string\n *\n * Attention: This function will modify the passed array!\n *\n * @param {Array<number>} numbers A list of floating point numbers.\n * @param {number} [opt_factor] The factor by which the numbers will be\n *     multiplied. The remaining decimal places will get rounded away.\n *     Default is `1e5`.\n * @return {string} The encoded string.\n * @api\n */\nexport function encodeFloats(numbers, opt_factor) {\n  const factor = opt_factor ? opt_factor : 1e5;\n  for (let i = 0, ii = numbers.length; i < ii; ++i) {\n    numbers[i] = Math.round(numbers[i] * factor);\n  }\n\n  return encodeSignedIntegers(numbers);\n}\n\n/**\n * Decode a list of floating point numbers from an encoded string\n *\n * @param {string} encoded An encoded string.\n * @param {number} [opt_factor] The factor by which the result will be divided.\n *     Default is `1e5`.\n * @return {Array<number>} A list of floating point numbers.\n * @api\n */\nexport function decodeFloats(encoded, opt_factor) {\n  const factor = opt_factor ? opt_factor : 1e5;\n  const numbers = decodeSignedIntegers(encoded);\n  for (let i = 0, ii = numbers.length; i < ii; ++i) {\n    numbers[i] /= factor;\n  }\n  return numbers;\n}\n\n/**\n * Encode a list of signed integers and return an encoded string\n *\n * Attention: This function will modify the passed array!\n *\n * @param {Array<number>} numbers A list of signed integers.\n * @return {string} The encoded string.\n */\nexport function encodeSignedIntegers(numbers) {\n  for (let i = 0, ii = numbers.length; i < ii; ++i) {\n    const num = numbers[i];\n    numbers[i] = num < 0 ? ~(num << 1) : num << 1;\n  }\n  return encodeUnsignedIntegers(numbers);\n}\n\n/**\n * Decode a list of signed integers from an encoded string\n *\n * @param {string} encoded An encoded string.\n * @return {Array<number>} A list of signed integers.\n */\nexport function decodeSignedIntegers(encoded) {\n  const numbers = decodeUnsignedIntegers(encoded);\n  for (let i = 0, ii = numbers.length; i < ii; ++i) {\n    const num = numbers[i];\n    numbers[i] = num & 1 ? ~(num >> 1) : num >> 1;\n  }\n  return numbers;\n}\n\n/**\n * Encode a list of unsigned integers and return an encoded string\n *\n * @param {Array<number>} numbers A list of unsigned integers.\n * @return {string} The encoded string.\n */\nexport function encodeUnsignedIntegers(numbers) {\n  let encoded = '';\n  for (let i = 0, ii = numbers.length; i < ii; ++i) {\n    encoded += encodeUnsignedInteger(numbers[i]);\n  }\n  return encoded;\n}\n\n/**\n * Decode a list of unsigned integers from an encoded string\n *\n * @param {string} encoded An encoded string.\n * @return {Array<number>} A list of unsigned integers.\n */\nexport function decodeUnsignedIntegers(encoded) {\n  const numbers = [];\n  let current = 0;\n  let shift = 0;\n  for (let i = 0, ii = encoded.length; i < ii; ++i) {\n    const b = encoded.charCodeAt(i) - 63;\n    current |= (b & 0x1f) << shift;\n    if (b < 0x20) {\n      numbers.push(current);\n      current = 0;\n      shift = 0;\n    } else {\n      shift += 5;\n    }\n  }\n  return numbers;\n}\n\n/**\n * Encode one single unsigned integer and return an encoded string\n *\n * @param {number} num Unsigned integer that should be encoded.\n * @return {string} The encoded string.\n */\nexport function encodeUnsignedInteger(num) {\n  let value,\n    encoded = '';\n  while (num >= 0x20) {\n    value = (0x20 | (num & 0x1f)) + 63;\n    encoded += String.fromCharCode(value);\n    num >>= 5;\n  }\n  value = num + 63;\n  encoded += String.fromCharCode(value);\n  return encoded;\n}\n\nexport default Polyline;\n","import Feature from '../src/ol/Feature.js';\nimport Map from '../src/ol/Map.js';\nimport Point from '../src/ol/geom/Point.js';\nimport Polyline from '../src/ol/format/Polyline.js';\nimport VectorSource from '../src/ol/source/Vector.js';\nimport View from '../src/ol/View.js';\nimport XYZ from '../src/ol/source/XYZ.js';\nimport {\n  Circle as CircleStyle,\n  Fill,\n  Icon,\n  Stroke,\n  Style,\n} from '../src/ol/style.js';\nimport {Tile as TileLayer, Vector as VectorLayer} from '../src/ol/layer.js';\nimport {getVectorContext} from '../src/ol/render.js';\n\nconst key = 'get_your_own_D6rA4zTHduk6KOKTXzGB';\nconst attributions =\n  '<a href=\"https://www.maptiler.com/copyright/\" target=\"_blank\">&copy; MapTiler</a> ' +\n  '<a href=\"https://www.openstreetmap.org/copyright\" target=\"_blank\">&copy; OpenStreetMap contributors</a>';\n\nconst center = [-5639523.95, -3501274.52];\nconst map = new Map({\n  target: document.getElementById('map'),\n  view: new View({\n    center: center,\n    zoom: 10,\n    minZoom: 2,\n    maxZoom: 19,\n  }),\n  layers: [\n    new TileLayer({\n      source: new XYZ({\n        attributions: attributions,\n        url: 'https://api.maptiler.com/maps/hybrid/{z}/{x}/{y}.jpg?key=' + key,\n        tileSize: 512,\n      }),\n    }),\n  ],\n});\n\n// The polyline string is read from a JSON similiar to those returned\n// by directions APIs such as Openrouteservice and Mapbox.\nfetch('data/polyline/route.json').then(function (response) {\n  response.json().then(function (result) {\n    const polyline = result.routes[0].geometry;\n\n    const route = new Polyline({\n      factor: 1e6,\n    }).readGeometry(polyline, {\n      dataProjection: 'EPSG:4326',\n      featureProjection: 'EPSG:3857',\n    });\n\n    const routeFeature = new Feature({\n      type: 'route',\n      geometry: route,\n    });\n    const startMarker = new Feature({\n      type: 'icon',\n      geometry: new Point(route.getFirstCoordinate()),\n    });\n    const endMarker = new Feature({\n      type: 'icon',\n      geometry: new Point(route.getLastCoordinate()),\n    });\n    const position = startMarker.getGeometry().clone();\n    const geoMarker = new Feature({\n      type: 'geoMarker',\n      geometry: position,\n    });\n\n    const styles = {\n      'route': new Style({\n        stroke: new Stroke({\n          width: 6,\n          color: [237, 212, 0, 0.8],\n        }),\n      }),\n      'icon': new Style({\n        image: new Icon({\n          anchor: [0.5, 1],\n          src: 'data/icon.png',\n        }),\n      }),\n      'geoMarker': new Style({\n        image: new CircleStyle({\n          radius: 7,\n          fill: new Fill({color: 'black'}),\n          stroke: new Stroke({\n            color: 'white',\n            width: 2,\n          }),\n        }),\n      }),\n    };\n\n    const vectorLayer = new VectorLayer({\n      source: new VectorSource({\n        features: [routeFeature, geoMarker, startMarker, endMarker],\n      }),\n      style: function (feature) {\n        return styles[feature.get('type')];\n      },\n    });\n\n    map.addLayer(vectorLayer);\n\n    const speedInput = document.getElementById('speed');\n    const startButton = document.getElementById('start-animation');\n    let animating = false;\n    let distance = 0;\n    let lastTime;\n\n    function moveFeature(event) {\n      const speed = Number(speedInput.value);\n      const time = event.frameState.time;\n      const elapsedTime = time - lastTime;\n      distance = (distance + (speed * elapsedTime) / 1e6) % 2;\n      lastTime = time;\n\n      const currentCoordinate = route.getCoordinateAt(\n        distance > 1 ? 2 - distance : distance\n      );\n      position.setCoordinates(currentCoordinate);\n      const vectorContext = getVectorContext(event);\n      vectorContext.setStyle(styles.geoMarker);\n      vectorContext.drawGeometry(position);\n      // tell OpenLayers to continue the postrender animation\n      map.render();\n    }\n\n    function startAnimation() {\n      animating = true;\n      lastTime = Date.now();\n      startButton.textContent = 'Stop Animation';\n      vectorLayer.on('postrender', moveFeature);\n      // hide geoMarker and trigger map render through change event\n      geoMarker.setGeometry(null);\n    }\n\n    function stopAnimation() {\n      animating = false;\n      startButton.textContent = 'Start Animation';\n\n      // Keep marker at current animation position\n      geoMarker.setGeometry(position);\n      vectorLayer.un('postrender', moveFeature);\n    }\n\n    startButton.addEventListener('click', function () {\n      if (animating) {\n        stopAnimation();\n      } else {\n        startAnimation();\n      }\n    });\n  });\n});\n"],"names":["flipXY","flatCoordinates","offset","end","stride","opt_dest","opt_destOffset","dest","destOffset","undefined","j","x","k","length","encodeUnsignedInteger","num","value","encoded","String","fromCharCode","Polyline","opt_options","options","dataProjection","getProjection","factor_","factor","geometryLayout_","geometryLayout","GeometryLayout","text","geometry","this","readGeometryFromText","Feature","readFeatureFromText","getStrideForLayout","opt_factor","d","lastNumbers","Array","numbers","current","shift","i","ii","b","charCodeAt","push","decodeUnsignedIntegers","decodeSignedIntegers","decodeFloats","decodeDeltas","coordinates","inflateCoordinates","lineString","LineString","transformGeometryWithOptions","adaptOptions","feature","getGeometry","writeGeometryText","assert","features","writeFeatureText","getFlatCoordinates","getStride","delta","Math","round","encodeUnsignedIntegers","encodeSignedIntegers","encodeFloats","encodeDeltas","TextFeature","map","Map","target","document","getElementById","view","View","center","zoom","minZoom","maxZoom","layers","TileLayer","source","XYZ","attributions","url","tileSize","fetch","then","response","json","result","polyline","routes","route","readGeometry","featureProjection","routeFeature","type","startMarker","Point","getFirstCoordinate","endMarker","getLastCoordinate","position","clone","geoMarker","styles","Style","stroke","Stroke","width","color","image","Icon","anchor","src","CircleStyle","radius","fill","Fill","vectorLayer","VectorLayer","VectorSource","style","get","addLayer","lastTime","speedInput","startButton","animating","distance","moveFeature","event","speed","Number","time","frameState","currentCoordinate","getCoordinateAt","setCoordinates","vectorContext","getVectorContext","setStyle","drawGeometry","render","addEventListener","textContent","setGeometry","un","Date","now","on"],"sourceRoot":""}