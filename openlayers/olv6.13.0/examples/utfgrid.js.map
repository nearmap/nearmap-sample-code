{"version":3,"file":"utfgrid.js","mappings":"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","sources":["webpack:///../src/ol/source/UTFGrid.js","webpack:///./utfgrid.js"],"sourcesContent":["/**\n * @module ol/source/UTFGrid\n */\n\nimport EventType from '../events/EventType.js';\nimport SourceState from './State.js';\nimport Tile from '../Tile.js';\nimport TileSource from './Tile.js';\nimport TileState from '../TileState.js';\nimport {applyTransform, intersects} from '../extent.js';\nimport {assert} from '../asserts.js';\nimport {createFromTemplates, nullTileUrlFunction} from '../tileurlfunction.js';\nimport {createXYZ, extentFromProjection} from '../tilegrid.js';\nimport {getKeyZXY} from '../tilecoord.js';\nimport {get as getProjection, getTransformFromProjections} from '../proj.js';\nimport {listenOnce} from '../events.js';\nimport {jsonp as requestJSONP} from '../net.js';\n\n/**\n * @typedef {Object} UTFGridJSON\n * @property {Array<string>} grid The grid.\n * @property {Array<string>} keys The keys.\n * @property {Object<string, Object>} [data] Optional data.\n */\n\nexport class CustomTile extends Tile {\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../TileState.js\").default} state State.\n   * @param {string} src Image source URI.\n   * @param {import(\"../extent.js\").Extent} extent Extent of the tile.\n   * @param {boolean} preemptive Load the tile when visible (before it's needed).\n   * @param {boolean} jsonp Load the tile as a script.\n   */\n  constructor(tileCoord, state, src, extent, preemptive, jsonp) {\n    super(tileCoord, state);\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.src_ = src;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.extent_ = extent;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.preemptive_ = preemptive;\n\n    /**\n     * @private\n     * @type {Array<string>}\n     */\n    this.grid_ = null;\n\n    /**\n     * @private\n     * @type {Array<string>}\n     */\n    this.keys_ = null;\n\n    /**\n     * @private\n     * @type {Object<string, Object>|undefined}\n     */\n    this.data_ = null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.jsonp_ = jsonp;\n  }\n\n  /**\n   * Get the image element for this tile.\n   * @return {HTMLImageElement} Image.\n   */\n  getImage() {\n    return null;\n  }\n\n  /**\n   * Synchronously returns data at given coordinate (if available).\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @return {*} The data.\n   */\n  getData(coordinate) {\n    if (!this.grid_ || !this.keys_) {\n      return null;\n    }\n    const xRelative =\n      (coordinate[0] - this.extent_[0]) / (this.extent_[2] - this.extent_[0]);\n    const yRelative =\n      (coordinate[1] - this.extent_[1]) / (this.extent_[3] - this.extent_[1]);\n\n    const row = this.grid_[Math.floor((1 - yRelative) * this.grid_.length)];\n\n    if (typeof row !== 'string') {\n      return null;\n    }\n\n    let code = row.charCodeAt(Math.floor(xRelative * row.length));\n    if (code >= 93) {\n      code--;\n    }\n    if (code >= 35) {\n      code--;\n    }\n    code -= 32;\n\n    let data = null;\n    if (code in this.keys_) {\n      const id = this.keys_[code];\n      if (this.data_ && id in this.data_) {\n        data = this.data_[id];\n      } else {\n        data = id;\n      }\n    }\n    return data;\n  }\n\n  /**\n   * Calls the callback (synchronously by default) with the available data\n   * for given coordinate (or `null` if not yet loaded).\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {function(*): void} callback Callback.\n   * @param {boolean} [opt_request] If `true` the callback is always async.\n   *                               The tile data is requested if not yet loaded.\n   */\n  forDataAtCoordinate(coordinate, callback, opt_request) {\n    if (this.state == TileState.EMPTY && opt_request === true) {\n      this.state = TileState.IDLE;\n      listenOnce(\n        this,\n        EventType.CHANGE,\n        function (e) {\n          callback(this.getData(coordinate));\n        },\n        this\n      );\n      this.loadInternal_();\n    } else {\n      if (opt_request === true) {\n        setTimeout(\n          function () {\n            callback(this.getData(coordinate));\n          }.bind(this),\n          0\n        );\n      } else {\n        callback(this.getData(coordinate));\n      }\n    }\n  }\n\n  /**\n   * Return the key to be used for all tiles in the source.\n   * @return {string} The key for all tiles.\n   */\n  getKey() {\n    return this.src_;\n  }\n\n  /**\n   * @private\n   */\n  handleError_() {\n    this.state = TileState.ERROR;\n    this.changed();\n  }\n\n  /**\n   * @param {!UTFGridJSON} json UTFGrid data.\n   * @private\n   */\n  handleLoad_(json) {\n    this.grid_ = json['grid'];\n    this.keys_ = json['keys'];\n    this.data_ = json['data'];\n\n    this.state = TileState.LOADED;\n    this.changed();\n  }\n\n  /**\n   * @private\n   */\n  loadInternal_() {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      if (this.jsonp_) {\n        requestJSONP(\n          this.src_,\n          this.handleLoad_.bind(this),\n          this.handleError_.bind(this)\n        );\n      } else {\n        const client = new XMLHttpRequest();\n        client.addEventListener('load', this.onXHRLoad_.bind(this));\n        client.addEventListener('error', this.onXHRError_.bind(this));\n        client.open('GET', this.src_);\n        client.send();\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} event The load event.\n   */\n  onXHRLoad_(event) {\n    const client = /** @type {XMLHttpRequest} */ (event.target);\n    // status will be 0 for file:// urls\n    if (!client.status || (client.status >= 200 && client.status < 300)) {\n      let response;\n      try {\n        response = /** @type {!UTFGridJSON} */ (\n          JSON.parse(client.responseText)\n        );\n      } catch (err) {\n        this.handleError_();\n        return;\n      }\n      this.handleLoad_(response);\n    } else {\n      this.handleError_();\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} event The error event.\n   */\n  onXHRError_(event) {\n    this.handleError_();\n  }\n\n  /**\n   */\n  load() {\n    if (this.preemptive_) {\n      this.loadInternal_();\n    } else {\n      this.setState(TileState.EMPTY);\n    }\n  }\n}\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [preemptive=true]\n * If `true` the UTFGrid source loads the tiles based on their \"visibility\".\n * This improves the speed of response, but increases traffic.\n * Note that if set to `false` (lazy loading), you need to pass `true` as\n * `opt_request` to the `forDataAtCoordinateAndResolution` method otherwise no\n * data will ever be loaded.\n * @property {boolean} [jsonp=false] Use JSONP with callback to load the TileJSON.\n * Useful when the server does not support CORS..\n * @property {import(\"./TileJSON.js\").Config} [tileJSON] TileJSON configuration for this source.\n * If not provided, `url` must be configured.\n * @property {string} [url] TileJSON endpoint that provides the configuration for this source.\n * Request will be made through JSONP. If not provided, `tileJSON` must be configured.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * Layer source for UTFGrid interaction data loaded from TileJSON format.\n * @api\n */\nclass UTFGrid extends TileSource {\n  /**\n   * @param {Options} options Source options.\n   */\n  constructor(options) {\n    super({\n      projection: getProjection('EPSG:3857'),\n      state: SourceState.LOADING,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.preemptive_ =\n      options.preemptive !== undefined ? options.preemptive : true;\n\n    /**\n     * @private\n     * @type {!import(\"../Tile.js\").UrlFunction}\n     */\n    this.tileUrlFunction_ = nullTileUrlFunction;\n\n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.template_ = undefined;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.jsonp_ = options.jsonp || false;\n\n    if (options.url) {\n      if (this.jsonp_) {\n        requestJSONP(\n          options.url,\n          this.handleTileJSONResponse.bind(this),\n          this.handleTileJSONError.bind(this)\n        );\n      } else {\n        const client = new XMLHttpRequest();\n        client.addEventListener('load', this.onXHRLoad_.bind(this));\n        client.addEventListener('error', this.onXHRError_.bind(this));\n        client.open('GET', options.url);\n        client.send();\n      }\n    } else if (options.tileJSON) {\n      this.handleTileJSONResponse(options.tileJSON);\n    } else {\n      assert(false, 51); // Either `url` or `tileJSON` options must be provided\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} event The load event.\n   */\n  onXHRLoad_(event) {\n    const client = /** @type {XMLHttpRequest} */ (event.target);\n    // status will be 0 for file:// urls\n    if (!client.status || (client.status >= 200 && client.status < 300)) {\n      let response;\n      try {\n        response = /** @type {import(\"./TileJSON.js\").Config} */ (\n          JSON.parse(client.responseText)\n        );\n      } catch (err) {\n        this.handleTileJSONError();\n        return;\n      }\n      this.handleTileJSONResponse(response);\n    } else {\n      this.handleTileJSONError();\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} event The error event.\n   */\n  onXHRError_(event) {\n    this.handleTileJSONError();\n  }\n\n  /**\n   * Return the template from TileJSON.\n   * @return {string|undefined} The template from TileJSON.\n   * @api\n   */\n  getTemplate() {\n    return this.template_;\n  }\n\n  /**\n   * Calls the callback (synchronously by default) with the available data\n   * for given coordinate and resolution (or `null` if not yet loaded or\n   * in case of an error).\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {function(*): void} callback Callback.\n   * @param {boolean} [opt_request] If `true` the callback is always async.\n   *                               The tile data is requested if not yet loaded.\n   * @api\n   */\n  forDataAtCoordinateAndResolution(\n    coordinate,\n    resolution,\n    callback,\n    opt_request\n  ) {\n    if (this.tileGrid) {\n      const z = this.tileGrid.getZForResolution(resolution, this.zDirection);\n      const tileCoord = this.tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = /** @type {!CustomTile} */ (\n        this.getTile(\n          tileCoord[0],\n          tileCoord[1],\n          tileCoord[2],\n          1,\n          this.getProjection()\n        )\n      );\n      tile.forDataAtCoordinate(coordinate, callback, opt_request);\n    } else {\n      if (opt_request === true) {\n        setTimeout(function () {\n          callback(null);\n        }, 0);\n      } else {\n        callback(null);\n      }\n    }\n  }\n\n  /**\n   * @protected\n   */\n  handleTileJSONError() {\n    this.setState(SourceState.ERROR);\n  }\n\n  /**\n   * TODO: very similar to ol/source/TileJSON#handleTileJSONResponse\n   * @protected\n   * @param {import(\"./TileJSON.js\").Config} tileJSON Tile JSON.\n   */\n  handleTileJSONResponse(tileJSON) {\n    const epsg4326Projection = getProjection('EPSG:4326');\n\n    const sourceProjection = this.getProjection();\n    let extent;\n    if (tileJSON['bounds'] !== undefined) {\n      const transform = getTransformFromProjections(\n        epsg4326Projection,\n        sourceProjection\n      );\n      extent = applyTransform(tileJSON['bounds'], transform);\n    }\n\n    const gridExtent = extentFromProjection(sourceProjection);\n    const minZoom = tileJSON['minzoom'] || 0;\n    const maxZoom = tileJSON['maxzoom'] || 22;\n    const tileGrid = createXYZ({\n      extent: gridExtent,\n      maxZoom: maxZoom,\n      minZoom: minZoom,\n    });\n    this.tileGrid = tileGrid;\n\n    this.template_ = tileJSON['template'];\n\n    const grids = tileJSON['grids'];\n    if (!grids) {\n      this.setState(SourceState.ERROR);\n      return;\n    }\n\n    this.tileUrlFunction_ = createFromTemplates(grids, tileGrid);\n\n    if (tileJSON['attribution'] !== undefined) {\n      const attributionExtent = extent !== undefined ? extent : gridExtent;\n      this.setAttributions(function (frameState) {\n        if (intersects(attributionExtent, frameState.extent)) {\n          return [tileJSON['attribution']];\n        }\n        return null;\n      });\n    }\n\n    this.setState(SourceState.READY);\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!CustomTile} Tile.\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const tileCoordKey = getKeyZXY(z, x, y);\n    if (this.tileCache.containsKey(tileCoordKey)) {\n      return this.tileCache.get(tileCoordKey);\n    } else {\n      const tileCoord = [z, x, y];\n      const urlTileCoord = this.getTileCoordForTileUrlFunction(\n        tileCoord,\n        projection\n      );\n      const tileUrl = this.tileUrlFunction_(\n        urlTileCoord,\n        pixelRatio,\n        projection\n      );\n      const tile = new CustomTile(\n        tileCoord,\n        tileUrl !== undefined ? TileState.IDLE : TileState.EMPTY,\n        tileUrl !== undefined ? tileUrl : '',\n        this.tileGrid.getTileCoordExtent(tileCoord),\n        this.preemptive_,\n        this.jsonp_\n      );\n      this.tileCache.set(tileCoordKey, tile);\n      return tile;\n    }\n  }\n\n  /**\n   * Marks a tile coord as being used, without triggering a load.\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   */\n  useTile(z, x, y) {\n    const tileCoordKey = getKeyZXY(z, x, y);\n    if (this.tileCache.containsKey(tileCoordKey)) {\n      this.tileCache.get(tileCoordKey);\n    }\n  }\n}\n\nexport default UTFGrid;\n","import Map from '../src/ol/Map.js';\nimport Overlay from '../src/ol/Overlay.js';\nimport TileJSON from '../src/ol/source/TileJSON.js';\nimport TileLayer from '../src/ol/layer/Tile.js';\nimport UTFGrid from '../src/ol/source/UTFGrid.js';\nimport View from '../src/ol/View.js';\n\nconst key =\n  'pk.eyJ1IjoiYWhvY2V2YXIiLCJhIjoiY2t0cGdwMHVnMGdlbzMxbDhwazBic2xrNSJ9.WbcTL9uj8JPAsnT9mgb7oQ';\n\nconst mapLayer = new TileLayer({\n  source: new TileJSON({\n    url:\n      'https://api.tiles.mapbox.com/v4/mapbox.geography-class.json?secure&access_token=' +\n      key,\n  }),\n});\n\nconst gridSource = new UTFGrid({\n  url:\n    'https://api.tiles.mapbox.com/v4/mapbox.geography-class.json?secure&access_token=' +\n    key,\n});\n\nconst gridLayer = new TileLayer({source: gridSource});\n\nconst view = new View({\n  center: [0, 0],\n  zoom: 1,\n});\n\nconst mapElement = document.getElementById('map');\nconst map = new Map({\n  layers: [mapLayer, gridLayer],\n  target: mapElement,\n  view: view,\n});\n\nconst infoElement = document.getElementById('country-info');\nconst flagElement = document.getElementById('country-flag');\nconst nameElement = document.getElementById('country-name');\n\nconst infoOverlay = new Overlay({\n  element: infoElement,\n  offset: [15, 15],\n  stopEvent: false,\n});\nmap.addOverlay(infoOverlay);\n\nconst displayCountryInfo = function (coordinate) {\n  const viewResolution = /** @type {number} */ (view.getResolution());\n  gridSource.forDataAtCoordinateAndResolution(\n    coordinate,\n    viewResolution,\n    function (data) {\n      // If you want to use the template from the TileJSON,\n      //  load the mustache.js library separately and call\n      //  info.innerHTML = Mustache.render(gridSource.getTemplate(), data);\n      mapElement.style.cursor = data ? 'pointer' : '';\n      if (data) {\n        flagElement.src = 'data:image/png;base64,' + data['flag_png'];\n        nameElement.innerHTML = data['admin'];\n      }\n      infoOverlay.setPosition(data ? coordinate : undefined);\n    }\n  );\n};\n\nmap.on('pointermove', function (evt) {\n  if (evt.dragging) {\n    return;\n  }\n  const coordinate = map.getEventCoordinate(evt.originalEvent);\n  displayCountryInfo(coordinate);\n});\n\nmap.on('click', function (evt) {\n  displayCountryInfo(evt.coordinate);\n});\n"],"names":["CustomTile","tileCoord","state","src","extent","preemptive","jsonp","src_","extent_","preemptive_","grid_","keys_","data_","jsonp_","coordinate","this","xRelative","yRelative","row","Math","floor","length","code","charCodeAt","data","id","callback","opt_request","TileState","listenOnce","EventType","e","getData","loadInternal_","setTimeout","bind","changed","json","requestJSONP","handleLoad_","handleError_","client","XMLHttpRequest","addEventListener","onXHRLoad_","onXHRError_","open","send","event","target","status","response","JSON","parse","responseText","err","setState","Tile","UTFGrid","options","projection","getProjection","SourceState","zDirection","undefined","tileUrlFunction_","nullTileUrlFunction","template_","url","handleTileJSONResponse","handleTileJSONError","tileJSON","assert","resolution","tileGrid","z","getZForResolution","getTileCoordForCoordAndZ","getTile","forDataAtCoordinate","epsg4326Projection","sourceProjection","transform","getTransformFromProjections","applyTransform","gridExtent","extentFromProjection","minZoom","maxZoom","createXYZ","grids","createFromTemplates","attributionExtent","setAttributions","frameState","intersects","x","y","pixelRatio","tileCoordKey","getKeyZXY","tileCache","containsKey","get","urlTileCoord","getTileCoordForTileUrlFunction","tileUrl","tile","getTileCoordExtent","set","TileSource","key","mapLayer","TileLayer","source","TileJSON","gridSource","gridLayer","view","View","center","zoom","mapElement","document","getElementById","map","Map","layers","infoElement","flagElement","nameElement","infoOverlay","Overlay","element","offset","stopEvent","addOverlay","displayCountryInfo","viewResolution","getResolution","forDataAtCoordinateAndResolution","style","cursor","innerHTML","setPosition","on","evt","dragging","getEventCoordinate","originalEvent"],"sourceRoot":""}