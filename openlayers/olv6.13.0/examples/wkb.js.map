{"version":3,"file":"wkb.js","mappings":"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","sources":["webpack:///../src/ol/format/WKB.js","webpack:///./wkb.js"],"sourcesContent":["/**\n * @module ol/format/WKB\n */\nimport Feature from '../Feature.js';\nimport FeatureFormat, {transformGeometryWithOptions} from './Feature.js';\nimport FormatType from './FormatType.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport {get as getProjection} from '../proj.js';\n\nimport SimpleGeometry from '../geom/SimpleGeometry.js';\nimport {assign} from '../obj.js';\n\n// WKB spec: https://www.ogc.org/standards/sfa\n// EWKB spec: https://raw.githubusercontent.com/postgis/postgis/2.1.0/doc/ZMSgeoms.txt\n\n/**\n * @const\n * @enum {number}\n */\nconst WKBGeometryType = {\n  POINT: 1,\n  LINE_STRING: 2,\n  POLYGON: 3,\n  MULTI_POINT: 4,\n  MULTI_LINE_STRING: 5,\n  MULTI_POLYGON: 6,\n  GEOMETRY_COLLECTION: 7,\n\n  /*\n  CIRCULAR_STRING: 8,\n  COMPOUND_CURVE: 9,\n  CURVE_POLYGON: 10,\n\n  MULTI_CURVE: 11,\n  MULTI_SURFACE: 12,\n  CURVE: 13,\n  SURFACE: 14,\n  */\n\n  POLYHEDRAL_SURFACE: 15,\n  TIN: 16,\n  TRIANGLE: 17,\n};\n\nclass WkbReader {\n  /**\n   * @param {DataView} view source to read\n   */\n  constructor(view) {\n    this.view_ = view;\n    this.pos_ = 0;\n\n    this.initialized_ = false;\n    this.isLittleEndian_ = false;\n    this.hasZ_ = false;\n    this.hasM_ = false;\n    /** @type {number|null} */\n    this.srid_ = null;\n\n    this.layout_ = GeometryLayout.XY;\n  }\n\n  /**\n   * @return {number} value\n   */\n  readUint8() {\n    return this.view_.getUint8(this.pos_++);\n  }\n\n  /**\n   * @param {boolean} [isLittleEndian] Whether read value as little endian\n   * @return {number} value\n   */\n  readUint32(isLittleEndian) {\n    return this.view_.getUint32(\n      (this.pos_ += 4) - 4,\n      isLittleEndian !== undefined ? isLittleEndian : this.isLittleEndian_\n    );\n  }\n\n  /**\n   * @param {boolean} [isLittleEndian] Whether read value as little endian\n   * @return {number} value\n   */\n  readDouble(isLittleEndian) {\n    return this.view_.getFloat64(\n      (this.pos_ += 8) - 8,\n      isLittleEndian !== undefined ? isLittleEndian : this.isLittleEndian_\n    );\n  }\n\n  /**\n   * @return {import('../coordinate.js').Coordinate} coords for Point\n   */\n  readPoint() {\n    /** @type import('../coordinate.js').Coordinate */\n    const coords = [];\n\n    coords.push(this.readDouble());\n    coords.push(this.readDouble());\n    if (this.hasZ_) {\n      coords.push(this.readDouble());\n    }\n    if (this.hasM_) {\n      coords.push(this.readDouble());\n    }\n\n    return coords;\n  }\n\n  /**\n   * @return {Array<import('../coordinate.js').Coordinate>} coords for LineString / LinearRing\n   */\n  readLineString() {\n    const numPoints = this.readUint32();\n\n    /** @type Array<import('../coordinate.js').Coordinate> */\n    const coords = [];\n    for (let i = 0; i < numPoints; i++) {\n      coords.push(this.readPoint());\n    }\n\n    return coords;\n  }\n\n  /**\n   * @return {Array<Array<import('../coordinate.js').Coordinate>>} coords for Polygon like\n   */\n  readPolygon() {\n    const numRings = this.readUint32();\n\n    /** @type Array<Array<import('../coordinate.js').Coordinate>> */\n    const rings = [];\n    for (let i = 0; i < numRings; i++) {\n      rings.push(this.readLineString()); // as a LinearRing\n    }\n\n    return rings;\n  }\n\n  /**\n   * @param {number} [expectedTypeId] Expected WKB Type ID\n   * @return {number} WKB Type ID\n   */\n  readWkbHeader(expectedTypeId) {\n    const byteOrder = this.readUint8();\n    const isLittleEndian = byteOrder > 0;\n\n    const wkbType = this.readUint32(isLittleEndian);\n    const wkbTypeThousandth = Math.floor((wkbType & 0x0fffffff) / 1000);\n    const hasZ =\n      Boolean(wkbType & 0x80000000) ||\n      wkbTypeThousandth === 1 ||\n      wkbTypeThousandth === 3;\n    const hasM =\n      Boolean(wkbType & 0x40000000) ||\n      wkbTypeThousandth === 2 ||\n      wkbTypeThousandth === 3;\n    const hasSRID = Boolean(wkbType & 0x20000000);\n    const typeId = (wkbType & 0x0fffffff) % 1000; // Assume 1000 is an upper limit for type ID\n    const layout = ['XY', hasZ ? 'Z' : '', hasM ? 'M' : ''].join('');\n\n    const srid = hasSRID ? this.readUint32(isLittleEndian) : null;\n\n    if (expectedTypeId !== undefined && expectedTypeId !== typeId) {\n      throw new Error('Unexpected WKB geometry type ' + typeId);\n    }\n\n    if (this.initialized_) {\n      // sanity checks\n      if (this.isLittleEndian_ !== isLittleEndian) {\n        throw new Error('Inconsistent endian');\n      }\n      if (this.layout_ !== layout) {\n        throw new Error('Inconsistent geometry layout');\n      }\n      if (srid && this.srid_ !== srid) {\n        throw new Error('Inconsistent coordinate system (SRID)');\n      }\n    } else {\n      this.isLittleEndian_ = isLittleEndian;\n      this.hasZ_ = hasZ;\n      this.hasM_ = hasM;\n      this.layout_ = layout;\n      this.srid_ = srid;\n      this.initialized_ = true;\n    }\n\n    return typeId;\n  }\n\n  /**\n   * @param {number} typeId WKB Type ID\n   * @return {any} values read\n   */\n  readWkbPayload(typeId) {\n    switch (typeId) {\n      case WKBGeometryType.POINT:\n        return this.readPoint();\n\n      case WKBGeometryType.LINE_STRING:\n        return this.readLineString();\n\n      case WKBGeometryType.POLYGON:\n      case WKBGeometryType.TRIANGLE:\n        return this.readPolygon();\n\n      case WKBGeometryType.MULTI_POINT:\n        return this.readMultiPoint();\n\n      case WKBGeometryType.MULTI_LINE_STRING:\n        return this.readMultiLineString();\n\n      case WKBGeometryType.MULTI_POLYGON:\n      case WKBGeometryType.POLYHEDRAL_SURFACE:\n      case WKBGeometryType.TIN:\n        return this.readMultiPolygon();\n\n      case WKBGeometryType.GEOMETRY_COLLECTION:\n        return this.readGeometryCollection();\n\n      default:\n        throw new Error(\n          'Unsupported WKB geometry type ' + typeId + ' is found'\n        );\n    }\n  }\n\n  /**\n   * @param {number} expectedTypeId Expected WKB Type ID\n   * @return {any} values read\n   */\n  readWkbBlock(expectedTypeId) {\n    return this.readWkbPayload(this.readWkbHeader(expectedTypeId));\n  }\n\n  /**\n   * @param {Function} reader reader function for each item\n   * @param {number} [expectedTypeId] Expected WKB Type ID\n   * @return {any} values read\n   */\n  readWkbCollection(reader, expectedTypeId) {\n    const num = this.readUint32();\n\n    const items = [];\n    for (let i = 0; i < num; i++) {\n      const result = reader.call(this, expectedTypeId);\n      if (result) {\n        items.push(result);\n      }\n    }\n\n    return items;\n  }\n\n  /**\n   * @return {Array<import('../coordinate.js').Coordinate>} coords for MultiPoint\n   */\n  readMultiPoint() {\n    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POINT);\n  }\n\n  /**\n   * @return {Array<Array<import('../coordinate.js').Coordinate>>} coords for MultiLineString like\n   */\n  readMultiLineString() {\n    return this.readWkbCollection(\n      this.readWkbBlock,\n      WKBGeometryType.LINE_STRING\n    );\n  }\n\n  /**\n   * @return {Array<Array<Array<import('../coordinate.js').Coordinate>>>} coords for MultiPolygon like\n   */\n  readMultiPolygon() {\n    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POLYGON);\n  }\n\n  /**\n   * @return {Array<import('../geom/Geometry.js').default>} array of geometries\n   */\n  readGeometryCollection() {\n    return this.readWkbCollection(this.readGeometry);\n  }\n\n  /**\n   * @return {import('../geom/Geometry.js').default} geometry\n   */\n  readGeometry() {\n    const typeId = this.readWkbHeader();\n    const result = this.readWkbPayload(typeId);\n\n    switch (typeId) {\n      case WKBGeometryType.POINT:\n        return new Point(\n          /** @type {import('../coordinate.js').Coordinate} */ (result),\n          this.layout_\n        );\n\n      case WKBGeometryType.LINE_STRING:\n        return new LineString(\n          /** @type {Array<import('../coordinate.js').Coordinate>} */ (result),\n          this.layout_\n        );\n\n      case WKBGeometryType.POLYGON:\n      case WKBGeometryType.TRIANGLE:\n        return new Polygon(\n          /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */ (\n            result\n          ),\n          this.layout_\n        );\n\n      case WKBGeometryType.MULTI_POINT:\n        return new MultiPoint(\n          /** @type {Array<import('../coordinate.js').Coordinate>} */ (result),\n          this.layout_\n        );\n\n      case WKBGeometryType.MULTI_LINE_STRING:\n        return new MultiLineString(\n          /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */ (\n            result\n          ),\n          this.layout_\n        );\n\n      case WKBGeometryType.MULTI_POLYGON:\n      case WKBGeometryType.POLYHEDRAL_SURFACE:\n      case WKBGeometryType.TIN:\n        return new MultiPolygon(\n          /** @type {Array<Array<Array<import('../coordinate.js').Coordinate>>>} */ (\n            result\n          ),\n          this.layout_\n        );\n\n      case WKBGeometryType.GEOMETRY_COLLECTION:\n        return new GeometryCollection(\n          /** @type {Array<import('../geom/Geometry.js').default>} */ (result)\n        );\n\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * @return {number|null} SRID in the EWKB. `null` if not defined.\n   */\n  getSrid() {\n    return this.srid_;\n  }\n}\n\nclass WkbWriter {\n  /**\n   * @type {object}\n   * @property {string} [layout] geometryLayout\n   * @property {boolean} [littleEndian=true] littleEndian\n   * @property {boolean} [ewkb=true] Whether writes in EWKB format\n   * @property {object} [nodata] NoData value for each axes\n   * @param {object} opts options\n   */\n  constructor(opts) {\n    opts = opts || {};\n\n    /** @type {string} */\n    this.layout_ = opts.layout;\n    this.isLittleEndian_ = opts.littleEndian !== false;\n\n    this.isEWKB_ = opts.ewkb !== false;\n\n    /** @type {Array<Array<number>>} */\n    this.writeQueue_ = [];\n\n    /**\n     * @type {object}\n     * @property {number} X NoData value for X\n     * @property {number} Y NoData value for Y\n     * @property {number} Z NoData value for Z\n     * @property {number} M NoData value for M\n     */\n    this.nodata_ = assign({X: 0, Y: 0, Z: 0, M: 0}, opts.nodata);\n  }\n\n  /**\n   * @param {number} value value\n   */\n  writeUint8(value) {\n    this.writeQueue_.push([1, value]);\n  }\n\n  /**\n   * @param {number} value value\n   */\n  writeUint32(value) {\n    this.writeQueue_.push([4, value]);\n  }\n\n  /**\n   * @param {number} value value\n   */\n  writeDouble(value) {\n    this.writeQueue_.push([8, value]);\n  }\n\n  /**\n   * @param {import('../coordinate.js').Coordinate} coords coords\n   * @param {import(\"../geom/GeometryLayout\").default} layout layout\n   */\n  writePoint(coords, layout) {\n    /**\n     * @type {object}\n     * @property {number} X NoData value for X\n     * @property {number} Y NoData value for Y\n     * @property {number} [Z] NoData value for Z\n     * @property {number} [M] NoData value for M\n     */\n    const coordsObj = assign.apply(\n      null,\n      layout.split('').map((axis, idx) => ({[axis]: coords[idx]}))\n    );\n\n    for (const axis of this.layout_) {\n      this.writeDouble(\n        axis in coordsObj ? coordsObj[axis] : this.nodata_[axis]\n      );\n    }\n  }\n\n  /**\n   * @param {Array<import('../coordinate.js').Coordinate>} coords coords\n   * @param {import(\"../geom/GeometryLayout\").default} layout layout\n   */\n  writeLineString(coords, layout) {\n    this.writeUint32(coords.length); // numPoints\n    for (let i = 0; i < coords.length; i++) {\n      this.writePoint(coords[i], layout);\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} rings rings\n   * @param {import(\"../geom/GeometryLayout\").default} layout layout\n   */\n  writePolygon(rings, layout) {\n    this.writeUint32(rings.length); // numRings\n    for (let i = 0; i < rings.length; i++) {\n      this.writeLineString(rings[i], layout); // as a LinearRing\n    }\n  }\n\n  /**\n   * @param {number} wkbType WKB Type ID\n   * @param {number} [srid] SRID\n   */\n  writeWkbHeader(wkbType, srid) {\n    wkbType %= 1000; // Assume 1000 is an upper limit for type ID\n    if (this.layout_.indexOf('Z') >= 0) {\n      wkbType += this.isEWKB_ ? 0x80000000 : 1000;\n    }\n    if (this.layout_.indexOf('M') >= 0) {\n      wkbType += this.isEWKB_ ? 0x40000000 : 2000;\n    }\n    if (this.isEWKB_ && Number.isInteger(srid)) {\n      wkbType |= 0x20000000;\n    }\n\n    this.writeUint8(this.isLittleEndian_ ? 1 : 0);\n    this.writeUint32(wkbType);\n    if (this.isEWKB_ && Number.isInteger(srid)) {\n      this.writeUint32(srid);\n    }\n  }\n\n  /**\n   * @param {Array<import('../coordinate.js').Coordinate>} coords coords\n   * @param {string} layout layout\n   */\n  writeMultiPoint(coords, layout) {\n    this.writeUint32(coords.length); // numItems\n    for (let i = 0; i < coords.length; i++) {\n      this.writeWkbHeader(1);\n      this.writePoint(coords[i], layout);\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} coords coords\n   * @param {string} layout layout\n   */\n  writeMultiLineString(coords, layout) {\n    this.writeUint32(coords.length); // numItems\n    for (let i = 0; i < coords.length; i++) {\n      this.writeWkbHeader(2);\n      this.writeLineString(coords[i], layout);\n    }\n  }\n\n  /**\n   * @param {Array<Array<Array<import('../coordinate.js').Coordinate>>>} coords coords\n   * @param {string} layout layout\n   */\n  writeMultiPolygon(coords, layout) {\n    this.writeUint32(coords.length); // numItems\n    for (let i = 0; i < coords.length; i++) {\n      this.writeWkbHeader(3);\n      this.writePolygon(coords[i], layout);\n    }\n  }\n\n  /**\n   * @param {Array<import('../geom/Geometry.js').default>} geometries geometries\n   */\n  writeGeometryCollection(geometries) {\n    this.writeUint32(geometries.length); // numItems\n\n    for (let i = 0; i < geometries.length; i++) {\n      this.writeGeometry(geometries[i]);\n    }\n  }\n\n  /**\n   * @param {import(\"../geom/Geometry.js\").default} geom geometry\n   * @param {import(\"../geom/GeometryLayout.js\").default} [layout] layout\n   * @return {import(\"../geom/GeometryLayout.js\").default} minumum layout made by common axes\n   */\n  findMinimumLayout(geom, layout = GeometryLayout.XYZM) {\n    /**\n     * @param {import(\"../geom/GeometryLayout.js\").default} a A\n     * @param {import(\"../geom/GeometryLayout.js\").default} b B\n     * @return {import(\"../geom/GeometryLayout.js\").default} minumum layout made by common axes\n     */\n    const GeometryLayout_min = (a, b) => {\n      if (a === b) {\n        return a;\n      }\n\n      if (a === GeometryLayout.XYZM) {\n        // anything `b` is minimum\n        return b;\n      }\n      if (b === GeometryLayout.XYZM) {\n        // anything `a` is minimum\n        return a;\n      }\n\n      // otherwise, incompatible\n      return GeometryLayout.XY;\n    };\n\n    if (geom instanceof SimpleGeometry) {\n      return GeometryLayout_min(geom.getLayout(), layout);\n    }\n\n    if (geom instanceof GeometryCollection) {\n      const geoms = geom.getGeometriesArray();\n      for (let i = 0; i < geoms.length && layout !== GeometryLayout.XY; i++) {\n        layout = this.findMinimumLayout(geoms[i], layout);\n      }\n    }\n\n    return layout;\n  }\n\n  /**\n   * @param {import(\"../geom/Geometry.js\").default} geom geometry\n   * @param {number} [srid] SRID\n   */\n  writeGeometry(geom, srid) {\n    const wkblut = {\n      [GeometryType.POINT]: WKBGeometryType.POINT,\n      [GeometryType.LINE_STRING]: WKBGeometryType.LINE_STRING,\n      [GeometryType.POLYGON]: WKBGeometryType.POLYGON,\n      [GeometryType.MULTI_POINT]: WKBGeometryType.MULTI_POINT,\n      [GeometryType.MULTI_LINE_STRING]: WKBGeometryType.MULTI_LINE_STRING,\n      [GeometryType.MULTI_POLYGON]: WKBGeometryType.MULTI_POLYGON,\n      [GeometryType.GEOMETRY_COLLECTION]: WKBGeometryType.GEOMETRY_COLLECTION,\n    };\n    const geomType = geom.getType();\n    const typeId = wkblut[geomType];\n\n    if (!typeId) {\n      throw new Error('GeometryType ' + geomType + ' is not supported');\n    }\n\n    // first call of writeGeometry() traverse whole geometries to determine its output layout if not specified on constructor.\n    if (!this.layout_) {\n      this.layout_ = this.findMinimumLayout(geom);\n    }\n\n    this.writeWkbHeader(typeId, srid);\n\n    if (geom instanceof SimpleGeometry) {\n      const writerLUT = {\n        [GeometryType.POINT]: this.writePoint,\n        [GeometryType.LINE_STRING]: this.writeLineString,\n        [GeometryType.POLYGON]: this.writePolygon,\n        [GeometryType.MULTI_POINT]: this.writeMultiPoint,\n        [GeometryType.MULTI_LINE_STRING]: this.writeMultiLineString,\n        [GeometryType.MULTI_POLYGON]: this.writeMultiPolygon,\n      };\n      writerLUT[geomType].call(this, geom.getCoordinates(), geom.getLayout());\n    } else if (geom instanceof GeometryCollection) {\n      this.writeGeometryCollection(geom.getGeometriesArray());\n    }\n  }\n\n  getBuffer() {\n    const byteLength = this.writeQueue_.reduce((acc, item) => acc + item[0], 0);\n    const buffer = new ArrayBuffer(byteLength);\n    const view = new DataView(buffer);\n\n    let pos = 0;\n    this.writeQueue_.forEach((item) => {\n      switch (item[0]) {\n        case 1:\n          view.setUint8(pos, item[1]);\n          break;\n        case 4:\n          view.setUint32(pos, item[1], this.isLittleEndian_);\n          break;\n        case 8:\n          view.setFloat64(pos, item[1], this.isLittleEndian_);\n          break;\n        default:\n          break;\n      }\n\n      pos += item[0];\n    });\n\n    return buffer;\n  }\n}\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [splitCollection=false] Whether to split GeometryCollections into multiple features on reading.\n * @property {boolean} [hex=true] Returns hex string instead of ArrayBuffer for output. This also is used as a hint internally whether it should load contents as text or ArrayBuffer on reading.\n * @property {boolean} [littleEndian=true] Use littleEndian for output.\n * @property {boolean} [ewkb=true] Use EWKB format for output.\n * @property {import(\"../geom/GeometryLayout\").default} [geometryLayout=null] Use specific coordinate layout for output features (null: auto detect)\n * @property {number} [nodataZ=0] If the `geometryLayout` doesn't match with geometry to be output, this value is used to fill missing coordinate value of Z.\n * @property {number} [nodataM=0] If the `geometryLayout` doesn't match with geometry to be output, this value is used to fill missing coordinate value of M.\n * @property {number|boolean} [srid=true] SRID for output. Specify integer value to enforce the value as a SRID. Specify `true` to extract from `dataProjection`. `false` to suppress the output. This option only takes effect when `ewkb` is `true`.\n */\n\n/**\n * @classdesc\n * Geometry format for reading and writing data in the `Well-Known Binary` (WKB) format.\n * Also supports `Extended Well-Known Binary` (EWKB) format, used in PostGIS for example.\n *\n * @api\n */\nclass WKB extends FeatureFormat {\n  /**\n   * @param {Options} [opt_options] Optional configuration object.\n   */\n  constructor(opt_options) {\n    super();\n\n    const options = opt_options ? opt_options : {};\n\n    this.splitCollection = Boolean(options.splitCollection);\n\n    this.viewCache_ = null;\n\n    this.hex_ = options.hex !== false;\n    this.littleEndian_ = options.littleEndian !== false;\n    this.ewkb_ = options.ewkb !== false;\n\n    this.layout_ = options.geometryLayout; // null for auto detect\n    this.nodataZ_ = options.nodataZ || 0;\n    this.nodataM_ = options.nodataM || 0;\n\n    this.srid_ = options.srid;\n  }\n\n  /**\n   * @return {import(\"./FormatType.js\").default} Format.\n   */\n  getType() {\n    return this.hex_ ? FormatType.TEXT : FormatType.ARRAY_BUFFER;\n  }\n\n  /**\n   * Read a single feature from a source.\n   *\n   * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n   * @return {import(\"../Feature.js\").FeatureLike} Feature.\n   * @api\n   */\n  readFeature(source, opt_options) {\n    return new Feature({\n      geometry: this.readGeometry(source, opt_options),\n    });\n  }\n\n  /**\n   * Read all features from a source.\n   *\n   * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n   * @return {Array<import(\"../Feature.js\").FeatureLike>} Features.\n   * @api\n   */\n  readFeatures(source, opt_options) {\n    let geometries = [];\n    const geometry = this.readGeometry(source, opt_options);\n    if (this.splitCollection && geometry instanceof GeometryCollection) {\n      geometries = geometry.getGeometriesArray();\n    } else {\n      geometries = [geometry];\n    }\n    return geometries.map((geometry) => new Feature({geometry}));\n  }\n\n  /**\n   * Read a single geometry from a source.\n   *\n   * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   * @api\n   */\n  readGeometry(source, opt_options) {\n    const view = getDataView(source);\n    if (!view) {\n      return null;\n    }\n\n    const reader = new WkbReader(view);\n    const geometry = reader.readGeometry();\n\n    this.viewCache_ = view; // cache for internal subsequent call of readProjection()\n    const options = this.getReadOptions(source, opt_options);\n    this.viewCache_ = null; // release\n\n    return transformGeometryWithOptions(geometry, false, options);\n  }\n\n  /**\n   * Read the projection from a source.\n   *\n   * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n   * @return {import(\"../proj/Projection.js\").default|undefined} Projection.\n   * @api\n   */\n  readProjection(source) {\n    const view = this.viewCache_ || getDataView(source);\n    if (!view) {\n      return undefined;\n    }\n\n    const reader = new WkbReader(view);\n    reader.readWkbHeader();\n\n    return (\n      (reader.getSrid() && getProjection('EPSG:' + reader.getSrid())) ||\n      undefined\n    );\n  }\n\n  /**\n   * Encode a feature in this format.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   * @api\n   */\n  writeFeature(feature, opt_options) {\n    return this.writeGeometry(feature.getGeometry(), opt_options);\n  }\n\n  /**\n   * Encode an array of features in this format.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   * @api\n   */\n  writeFeatures(features, opt_options) {\n    return this.writeGeometry(\n      new GeometryCollection(features.map((f) => f.getGeometry())),\n      opt_options\n    );\n  }\n\n  /**\n   * Write a single geometry in this format.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   * @api\n   */\n  writeGeometry(geometry, opt_options) {\n    const options = this.adaptOptions(opt_options);\n\n    const writer = new WkbWriter({\n      layout: this.layout_,\n      littleEndian: this.littleEndian_,\n      ewkb: this.ewkb_,\n\n      nodata: {\n        Z: this.nodataZ_,\n        M: this.nodataM_,\n      },\n    });\n\n    // extract SRID from `dataProjection`\n    let srid = Number.isInteger(this.srid_) ? Number(this.srid_) : null;\n    if (this.srid_ !== false && !Number.isInteger(this.srid_)) {\n      const dataProjection =\n        options.dataProjection && getProjection(options.dataProjection);\n      if (dataProjection) {\n        const code = dataProjection.getCode();\n        if (code.indexOf('EPSG:') === 0) {\n          srid = Number(code.substring(5));\n        }\n      }\n    }\n\n    writer.writeGeometry(\n      transformGeometryWithOptions(geometry, true, options),\n      srid\n    );\n    const buffer = writer.getBuffer();\n\n    return this.hex_ ? encodeHexString(buffer) : buffer;\n  }\n}\n\n/**\n * @param {ArrayBuffer} buffer source buffer\n * @return {string} encoded hex string\n */\nfunction encodeHexString(buffer) {\n  const view = new Uint8Array(buffer);\n  return Array.from(view.values())\n    .map((x) => (x < 16 ? '0' : '') + Number(x).toString(16).toUpperCase())\n    .join('');\n}\n\n/**\n * @param {string} text source text\n * @return {DataView} decoded binary buffer\n */\nfunction decodeHexString(text) {\n  const buffer = new Uint8Array(text.length / 2);\n  for (let i = 0; i < text.length / 2; i++) {\n    buffer[i] = parseInt(text.substr(i * 2, 2), 16);\n  }\n  return new DataView(buffer.buffer);\n}\n\n/**\n * @param {string | ArrayBuffer | ArrayBufferView} source source\n * @return {DataView} data view\n */\nfunction getDataView(source) {\n  if (typeof source === 'string') {\n    return decodeHexString(source);\n  } else if (ArrayBuffer.isView(source)) {\n    if (source instanceof DataView) {\n      return source;\n    }\n    return new DataView(source.buffer, source.byteOffset, source.byteLength);\n  } else if (source instanceof ArrayBuffer) {\n    return new DataView(source);\n  } else {\n    return null;\n  }\n}\n\nexport default WKB;\n","import Map from '../src/ol/Map.js';\nimport View from '../src/ol/View.js';\nimport WKB from '../src/ol/format/WKB.js';\nimport {OSM, Vector as VectorSource} from '../src/ol/source.js';\nimport {Tile as TileLayer, Vector as VectorLayer} from '../src/ol/layer.js';\n\nconst raster = new TileLayer({\n  source: new OSM(),\n});\n\nconst wkb =\n  '0103000000010000000500000054E3A59BC4602540643BDF4F8D1739C05C8FC2F5284C4140EC51B81E852B34C0D578E926316843406F1283C0CAD141C01B2FDD2406012B40A4703D0AD79343C054E3A59BC4602540643BDF4F8D1739C0';\n\nconst format = new WKB();\n\nconst feature = format.readFeature(wkb, {\n  dataProjection: 'EPSG:4326',\n  featureProjection: 'EPSG:3857',\n});\n\nconst vector = new VectorLayer({\n  source: new VectorSource({\n    features: [feature],\n  }),\n});\n\nconst map = new Map({\n  layers: [raster, vector],\n  target: 'map',\n  view: new View({\n    center: [2952104.0199, -3277504.823],\n    zoom: 4,\n  }),\n});\n"],"names":["WKBGeometryType","WkbReader","view","this","view_","pos_","initialized_","isLittleEndian_","hasZ_","hasM_","srid_","layout_","GeometryLayout","getUint8","isLittleEndian","getUint32","undefined","getFloat64","coords","push","readDouble","numPoints","readUint32","i","readPoint","numRings","rings","readLineString","expectedTypeId","readUint8","wkbType","wkbTypeThousandth","Math","floor","hasZ","Boolean","hasM","hasSRID","typeId","layout","join","srid","Error","readPolygon","readMultiPoint","readMultiLineString","readMultiPolygon","readGeometryCollection","readWkbPayload","readWkbHeader","reader","num","items","result","call","readWkbCollection","readWkbBlock","readGeometry","Point","LineString","Polygon","MultiPoint","MultiLineString","MultiPolygon","GeometryCollection","WkbWriter","opts","littleEndian","isEWKB_","ewkb","writeQueue_","nodata_","assign","X","Y","Z","M","nodata","value","coordsObj","split","map","axis","idx","writeDouble","writeUint32","length","writePoint","writeLineString","indexOf","Number","isInteger","writeUint8","writeWkbHeader","writePolygon","geometries","writeGeometry","geom","GeometryLayout_min","a","b","SimpleGeometry","getLayout","geoms","getGeometriesArray","findMinimumLayout","wkblut","GeometryType","geomType","getType","writeMultiPoint","writeMultiLineString","writeMultiPolygon","getCoordinates","writeGeometryCollection","byteLength","reduce","acc","item","buffer","ArrayBuffer","DataView","pos","forEach","setUint8","setUint32","setFloat64","getDataView","source","text","Uint8Array","parseInt","substr","decodeHexString","isView","byteOffset","WKB","opt_options","options","splitCollection","viewCache_","hex_","hex","littleEndian_","ewkb_","geometryLayout","nodataZ_","nodataZ","nodataM_","nodataM","FormatType","Feature","geometry","getReadOptions","transformGeometryWithOptions","getSrid","getProjection","feature","getGeometry","features","f","adaptOptions","writer","dataProjection","code","getCode","substring","getBuffer","Array","from","values","x","toString","toUpperCase","encodeHexString","FeatureFormat","raster","TileLayer","OSM","readFeature","featureProjection","vector","VectorLayer","VectorSource","Map","layers","target","View","center","zoom"],"sourceRoot":""}